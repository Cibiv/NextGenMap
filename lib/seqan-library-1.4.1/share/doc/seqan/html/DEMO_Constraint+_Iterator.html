<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="dddoc_html.css" type="text/css" /><title>Constraint Iterator</title></head><body><table id=main_table cellspacing=0 cellpadding=0><tr><td valign=top><iframe frameborder=0 id=navigation src="INDEX_Demo_Index.html#Constraint Iterator"></iframe></td><td valign=top><div id=content><div class=page_category>Example Program</div><div class=page_title>Constraint Iterator</div><div id=summary><div class=text>Example for using node predicates on a deferred suffix tree.</div></div><div class=section id=description><div class=text_block><div class=text_sub_block> Given a sequences, we want to find all substrings <span class=code><nobr>s</nobr></span> that fulfill certain constraints.
The relative probabilty to see <span class=code><nobr>s</nobr></span> should be at least <span class=code><nobr>p_min</nobr></span>. <span class=code><nobr>s</nobr></span> should also be not longer than
<span class=code><nobr>replen_max</nobr></span>.
The latter constraint is a anti-monotonic pattern predicate and can be used in conjunction with the
first constraint to cut of the trunk of a suffix tree. Only the top of the suffix tree contains candidates
that might fulfill both predicates, so we can use an <a href="CLASS_Index.html" title="Contains preprocessing data of a fixed text. In combination with a Class.Finder or a Spec.VSTree Iterator it allows fast dictionary look-up and advanced computations." >Index</a> based on a deferred suffix tree (see <a href="SPEC_Index_Wotd.html" title="This index represents a lazy suffix tree, meaning that a path from the tree of the index in only computed, if it is traversed. For details see Giegerich et al., &quot;Efficient implementation of lazy suffix trees&quot;." >IndexWotd</a>).
The following example demonstrates how to iterate over all suffix tree nodes fulfilling the constraints and output them.</div></div></div><div class=section_headline>File "<a href="index_node_predicate.cpp">index_node_predicate.cpp</a>"</div><div class=codefile >A tutorial showing how to extent an index with a node predicate.
<table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>1</td><td class=content><nobr>#include&nbsp;&lt;iostream&gt;<br ></nobr></td></tr><tr><td align=right class=linenumber>2</td><td class=content><nobr>#include&nbsp;&lt;seqan/index.h&gt;<br ></nobr></td></tr><tr><td align=right class=linenumber>3</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>4</td><td class=content><nobr>using&nbsp;namespace&nbsp;seqan;<br ></nobr></td></tr><tr><td align=right class=linenumber>5</td><td class=content><nobr><br ></nobr></td></tr></table><div class=comment> constraint parameters
</div><table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>6</td><td class=content><nobr>struct&nbsp;TMyConstraints&nbsp;{<br ></nobr></td></tr><tr><td align=right class=linenumber>7</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;p_min;<br ></nobr></td></tr><tr><td align=right class=linenumber>8</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;replen_max;<br ></nobr></td></tr><tr><td align=right class=linenumber>9</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;_cachedPred;<br ></nobr></td></tr><tr><td align=right class=linenumber>10</td><td class=content><nobr>};<br ></nobr></td></tr><tr><td align=right class=linenumber>11</td><td class=content><nobr><br ></nobr></td></tr></table><div class=comment> SeqAn extensions
</div><table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>12</td><td class=content><nobr>namespace&nbsp;seqan&nbsp;<br ></nobr></td></tr><tr><td align=right class=linenumber>13</td><td class=content><nobr>{<br ></nobr></td></tr><tr><td align=right class=linenumber>14</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;custom&nbsp;TSpec&nbsp;for&nbsp;our&nbsp;customized&nbsp;wotd-Index<br ></nobr></td></tr><tr><td align=right class=linenumber>15</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;TMyIndex;<br ></nobr></td></tr><tr><td align=right class=linenumber>16</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>17</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;TText&gt;<br ></nobr></td></tr><tr><td align=right class=linenumber>18</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;Cargo&lt;Index&lt;TText,&nbsp;IndexWotd&lt;TMyIndex&gt;&nbsp;&gt;&nbsp;&gt;&nbsp;{<br ></nobr></td></tr><tr><td align=right class=linenumber>19</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;TMyConstraints&nbsp;Type;<br ></nobr></td></tr><tr><td align=right class=linenumber>20</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;};<br ></nobr></td></tr><tr><td align=right class=linenumber>21</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>22</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;node&nbsp;predicate<br ></nobr></td></tr><tr><td align=right class=linenumber>23</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;TText,&nbsp;typename&nbsp;TSpec&gt;<br ></nobr></td></tr><tr><td align=right class=linenumber>24</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;nodePredicate(Iter&lt;Index&lt;TText,&nbsp;IndexWotd&lt;TMyIndex&gt;&nbsp;&gt;,&nbsp;TSpec&gt;&nbsp;&amp;it)&nbsp;<br ></nobr></td></tr><tr><td align=right class=linenumber>25</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;{<br ></nobr></td></tr><tr><td align=right class=linenumber>26</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TMyConstraints&nbsp;&amp;cons&nbsp;=&nbsp;cargo(container(it));<br ></nobr></td></tr><tr><td align=right class=linenumber>27</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;delta&nbsp;=&nbsp;countSequences(container(it))&nbsp;*&nbsp;repLength(it);<br ></nobr></td></tr><tr><td align=right class=linenumber>28</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;textLen&nbsp;=&nbsp;length(container(it));<br ></nobr></td></tr><tr><td align=right class=linenumber>29</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>30</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(textLen&nbsp;&lt;=&nbsp;delta)&nbsp;return&nbsp;cons._cachedPred&nbsp;=&nbsp;true;<br ></nobr></td></tr><tr><td align=right class=linenumber>31</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cons._cachedPred&nbsp;=&nbsp;<br ></nobr></td></tr><tr><td align=right class=linenumber>32</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((double)countOccurrences(it)&nbsp;/&nbsp;(double)(textLen&nbsp;-&nbsp;delta))&nbsp;&gt;&nbsp;cons.p_min;<br ></nobr></td></tr><tr><td align=right class=linenumber>33</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;}<br ></nobr></td></tr><tr><td align=right class=linenumber>34</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>35</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;monotonic&nbsp;hull<br ></nobr></td></tr><tr><td align=right class=linenumber>36</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;typename&nbsp;TText,&nbsp;typename&nbsp;TSpec&gt;<br ></nobr></td></tr><tr><td align=right class=linenumber>37</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;nodeHullPredicate(Iter&lt;Index&lt;TText,&nbsp;IndexWotd&lt;TMyIndex&gt;&nbsp;&gt;,&nbsp;TSpec&gt;&nbsp;&amp;it)&nbsp;<br ></nobr></td></tr><tr><td align=right class=linenumber>38</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;{<br ></nobr></td></tr><tr><td align=right class=linenumber>39</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TMyConstraints&nbsp;const&nbsp;&amp;cons&nbsp;=&nbsp;cargo(container(it));<br ></nobr></td></tr><tr><td align=right class=linenumber>40</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;textLen&nbsp;=&nbsp;length(container(it));<br ></nobr></td></tr><tr><td align=right class=linenumber>41</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>42</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(repLength(it)&nbsp;&gt;&nbsp;cons.replen_max)&nbsp;return&nbsp;false;<br ></nobr></td></tr><tr><td align=right class=linenumber>43</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>44</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;delta&nbsp;=&nbsp;countSequences(container(it))&nbsp;*&nbsp;cons.replen_max;<br ></nobr></td></tr><tr><td align=right class=linenumber>45</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(textLen&nbsp;&lt;=&nbsp;delta)&nbsp;return&nbsp;true;<br ></nobr></td></tr><tr><td align=right class=linenumber>46</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;((double)countOccurrences(it)&nbsp;/&nbsp;<br ></nobr></td></tr><tr><td align=right class=linenumber>47</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(double)(textLen&nbsp;-&nbsp;delta))&nbsp;&gt;&nbsp;cons.p_min;<br ></nobr></td></tr><tr><td align=right class=linenumber>48</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;}<br ></nobr></td></tr><tr><td align=right class=linenumber>49</td><td class=content><nobr>}<br ></nobr></td></tr><tr><td align=right class=linenumber>50</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>51</td><td class=content><nobr>int&nbsp;main&nbsp;()<br ></nobr></td></tr><tr><td align=right class=linenumber>52</td><td class=content><nobr>{<br ></nobr></td></tr></table><div class=comment>We begin with a <a href="CLASS_String.html" title="A sequence container with generic alphabet and many specializations." >String</a> to store our sequence.
</div><table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>53</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;String&lt;char&gt;&nbsp;myString&nbsp;=&nbsp;"How&nbsp;many&nbsp;wood&nbsp;would&nbsp;a&nbsp;woodchuck&nbsp;chuck.";<br ></nobr></td></tr><tr><td align=right class=linenumber>54</td><td class=content><nobr><br ></nobr></td></tr></table><div class=comment>Then we create our customized index which is a specialization
of the deferred <a href="CLASS_Index.html" title="Contains preprocessing data of a fixed text. In combination with a Class.Finder or a Spec.VSTree Iterator it allows fast dictionary look-up and advanced computations." >wotd-Index</a>
</div><table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>55</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;Index&lt;&nbsp;String&lt;char&gt;,&nbsp;IndexWotd&lt;TMyIndex&gt;&nbsp;&gt;&nbsp;TMyIndex;<br ></nobr></td></tr><tr><td align=right class=linenumber>56</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;TMyIndex&nbsp;myIndex(myString);<br ></nobr></td></tr><tr><td align=right class=linenumber>57</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>58</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;cargo(myIndex).replen_max&nbsp;=&nbsp;10;<br ></nobr></td></tr><tr><td align=right class=linenumber>59</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;cargo(myIndex).p_min&nbsp;=&nbsp;0.05;<br ></nobr></td></tr><tr><td align=right class=linenumber>60</td><td class=content><nobr><br ></nobr></td></tr></table><div class=comment>To find all strings that fulfill our constraints,
we simply do a dfs-traversal via <a href="FUNCTION.go_Begin.html" title="Iterates to the first position of a container." >goBegin</a> and <a href="FUNCTION.go_Next.html" title="Iterates to next position." >goNext</a>.
</div><table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>61</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;Iterator&lt;&nbsp;TMyIndex,&nbsp;TopDown&lt;ParentLinks&lt;&gt;&nbsp;&gt;&nbsp;&gt;::Type&nbsp;TConstrainedIterator;<br ></nobr></td></tr><tr><td align=right class=linenumber>62</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;TConstrainedIterator&nbsp;myConstrainedIterator(myIndex);<br ></nobr></td></tr><tr><td align=right class=linenumber>63</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>64</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;goBegin(myConstrainedIterator);<br ></nobr></td></tr><tr><td align=right class=linenumber>65</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!atEnd(myConstrainedIterator))<br ></nobr></td></tr><tr><td align=right class=linenumber>66</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;{<br ></nobr></td></tr><tr><td align=right class=linenumber>67</td><td class=content><nobr><br ></nobr></td></tr></table><div class=comment><a href="FUNCTION.count_Occurrences.html" title="Returns the number of occurrences of Function.representative substring or a q-gram in the index text." >countOccurrences</a> returns the number of hits of the representative.
</div><table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>68</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;countOccurrences(myConstrainedIterator)&nbsp;&lt;&lt;&nbsp;"x&nbsp;&nbsp;";<br ></nobr></td></tr><tr><td align=right class=linenumber>69</td><td class=content><nobr><br ></nobr></td></tr></table><div class=comment>The representative string can be determined with <a href="FUNCTION.representative.html" title="Returns a substring representing the path from root to iterator node." >representative</a>
</div><table cellspacing=0 cellpadding=0 class=codefiletab><tr><td align=right class=linenumber>70</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"\t\""&nbsp;&lt;&lt;&nbsp;representative(myConstrainedIterator)&nbsp;&lt;&lt;&nbsp;'\"'&nbsp;&lt;&lt;&nbsp;std::endl;<br ></nobr></td></tr><tr><td align=right class=linenumber>71</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>72</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goNext(myConstrainedIterator);<br ></nobr></td></tr><tr><td align=right class=linenumber>73</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;}<br ></nobr></td></tr><tr><td align=right class=linenumber>74</td><td class=content><nobr><br ></nobr></td></tr><tr><td align=right class=linenumber>75</td><td class=content><nobr>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br ></nobr></td></tr><tr><td align=right class=linenumber>76</td><td class=content><nobr>}<br ></nobr></td></tr></table></div><div class=section id=output><div class=section_headline>Output</div><div class=text_block><div class=text_sub_block> </div><div class=code_sub_block><span class=code><nobr>weese@tanne:~/seqan$&nbsp;cd&nbsp;demos<br >weese@tanne:~/seqan/demos$&nbsp;make&nbsp;index_node_predicate<br >weese@tanne:~/seqan/demos$&nbsp;./index_node_predicate<br >38x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;""<br >6x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;"<br >3x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;wo"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;wood"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"a"<br >4x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"c"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"chuck"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ck"<br >3x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"d"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"d&nbsp;"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"huck"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"k"<br >6x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"o"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"od"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ood"<br >3x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"u"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"uck"<br >4x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"w"<br >3x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"wo"<br >2x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"wood"<br >weese@tanne:~/seqan/demos$</nobr></span></div></div></div><div class="section" id="demofor"><div class="section_headline">See</div><div class="text_block"><span class="link_text"><a href="SPEC_Index_Wotd.html" title="This index represents a lazy suffix tree, meaning that a path from the tree of the index in only computed, if it is traversed. For details see Giegerich et al., &quot;Efficient implementation of lazy suffix trees&quot;." >IndexWotd</a></span>, <span class="link_text"><a href="FUNCTION.node_Predicate.html" title="If false this node will be skipped during the bottom-up traversal." >nodePredicate</a></span>, <span class="link_text"><a href="FUNCTION.representative.html" title="Returns a substring representing the path from root to iterator node." >representative</a></span>, <span class="link_text"><a href="FUNCTION.node_Hull_Predicate.html" title="If false this node and its subtree is concealed." >nodeHullPredicate</a></span>, <span class="link_text"><a href="SPEC_Top_Down_History+_Iterator.html" title="String tree iterator that can go down, right, and up. Supports depth-first search." >TopDownHistory Iterator</a></span>, <span class="link_text"><a href="FUNCTION.count_Occurrences.html" title="Returns the number of occurrences of Function.representative substring or a q-gram in the index text." >countOccurrences</a></span></div></div><div class=page_footline>SeqAn - Sequence Analysis Library - <a href="http://www.seqan.de">www.seqan.de</a></div><div id=page_widthblock>&nbsp;</div></div></td></tr></table><p style="font-size:50%; color: #909090">Page built @2013/07/11 10:43:56</p></body></html>